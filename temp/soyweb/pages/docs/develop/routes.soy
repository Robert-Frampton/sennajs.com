---
description: "Routes Guide"
layout: "guide"
title: "Routes"
category: "Develop"
weight: 6
srcFilePath: src/pages/docs/develop/routes.md
---

{namespace docsDevelopRoutesHtml}

/**
 * @param page
 * @param site
 */
{template .render}
	{call guide.render data="all"}
		{param content kind="html"}
			<h1>Routes</h1>
<article id="Routes">
<h2>Routes</h2>
<p>As seen on the previous example, you can register <code>senna.Route</code> on <code>senna.App</code>. A route is a tuple containing a path and a handler function:</p>
{call ElectricCode.render}{param code kind="text"}{literal}var route = new senna.Route('/path/file.html', function() {
  // Fires when a link with path /path/file.html is clicked.
});{/literal}{/param}{param mode: 'text' /}{/call}<p>The path also supports strings, regular expressions or functions.</p>
{call ElectricCode.render}{param code kind="text"}{literal}var route = new senna.Route(/.*/, function() {
  // Fires when any link is clicked.
});{/literal}{/param}{param mode: 'text' /}{/call}{call ElectricCode.render}{param code kind="text"}{literal}var resolvePath = function() {
  return '/path/file.html';
}
var route = new senna.Route(resolvePath, function() {
  // Fires when a link with path /path/file.html is clicked.
});{/literal}{/param}{param mode: 'text' /}{/call}<p>From the handler callback you can update parts of your page, though it is hard to grow your application from a simple callback like this. For that reason, Senna.js provides <code>senna.Screen</code>. A screen is nothing more than a special type of route handler that provides an asynchronous lifecycle. The following section will detail how <code>senna.Screen</code> can help you manage your surfaces.</p>
</article>
			<input type="hidden" value="{$page.title}">
			<input type="hidden" value="{$site.title}">
		{/param}
	{/call}
{/template}


/**
 *
 */
{template .soyweb}
	{call base.render data="all"}
		{param content kind="html"}
			{call .render data="all" /}
		{/param}
	{/call}
{/template}
